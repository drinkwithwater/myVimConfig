

"not used , trying to init session.vim if existed
function! s:init()
	let result=split(system("dir"))
	for fileName in result
		if fileName=="session.vim"
			source session.vim
			return
		endif
	endfor
endfunction

" save opened state with session.vim...
" command! -n=0 -bar WQ call s:saveCloseProject()
command WQ wqa
command Q qa
autocmd VimLeavePre * call s:recordCloseProject()
function! s:saveCloseProject()
	call s:recordCloseProject()
	wqa
endfunction
function! s:recordCloseProject()
	let pageChange=":tabn ".string(tabpagenr())
	let sessionFileName=expand("~")."/.vimtmp/session.vim"
	let allFileNames=s:GetAllBufferName()
	let outLine=[]
	if len(allFileNames)>=1
		call add(outLine,":edit ".allFileNames[0])
	endif
	for name in allFileNames[1:]
		call add(outLine,":tabe ".name)
	endfor
	call add(outLine,pageChange)
	call writefile(outLine,sessionFileName)
endfunction

function! s:GetAllBufferName()
	let reList=[]
	for pageNum in range(1,tabpagenr("$"))
		for bufNum in tabpagebuflist(pageNum)
			if match(bufname(bufNum),"NERD_tree")<0
				let bufFileName = expand("#".bufNum.":p")
				if filereadable(bufFileName)
					call add(reList,bufFileName)
				endif
			endif
		endfor
	endfor
	return reList
endfunction

" make tag and open tag file below
command! -n=0 -bar TAG call s:VsctagsRight()
function! s:VsctagsRight()
	call system("ctags -f ~/.vimtmp/tags --sort=no ".expand('%:p'))
	botright 10 split ~/.vimtmp/tags
	nnoremap <buffer><silent>o <C-]><C-w>w:q<CR>
	nnoremap <buffer><silent>t <C-w><C-]><C-w>T
	setlocal nomodifiable
endfunction

" git diff in local
command! -n=0 -bar DIFF call s:Vsgitdiff()
function! s:Vsgitdiff()
	let curPath = getcwd()
	let filePath = expand("%:p:h")
	exec "cd ".filePath
	call system("git diff ".expand("%:p")." > ~/.vimtmp/DIFF_TEMP")
	exec "cd ".curPath
	tabe ~/.vimtmp/DIFF_TEMP
endfunction


" auto input setter & getter
function! s:defaultClass()
	return split(expand("%:t"),"[\.]")[0]
endfunction
function! s:upperFirst(word)
	if 'a'<=a:word[0] && a:word[0]<='z'
		let firstNum = char2nr(a:word[0])+char2nr('A')-char2nr('a')
		return nr2char(firstNum).a:word[1:]
	else
		return a:word
	endif
endfunction

"
command! -n=* -bar AutoSet call s:luaAutoGetSet("set",<f-args>)
command! -n=* -bar AutoGet call s:luaAutoGetSet("get",<f-args>)
function! s:luaAutoGetSet(...)
	let var = ""
	let class = ""
	let appendLineNum = line('.')
	if a:0==1
		let appendLineNum = line('$') - 1
		let class = s:upperFirst(s:defaultClass())
		let var = s:upperFirst(expand("<cword>"))
	elseif a:0==2
		let appendLineNum = line('.')
		let class = s:upperFirst(s:defaultClass())
		let var = s:upperFirst(a:2)
	elseif a:0==3
		let appendLineNum = line('.')
		let class = s:upperFirst(a:2)
		let var = s:upperFirst(a:3)
	else
		echo "args num not valid : ".a:0
		return
	end

	let allLine = s:luaGen(a:1,l:class,l:var)
	for line in allLine
		call append(appendLineNum, line)
		let appendLineNum = l:appendLineNum + 1
	endfor
endfunction

function! s:luaGen(sg,class,var)
	let setter1="function ".a:class.":set".a:var."(v".a:var.")"
	let setter2="\tself.m".a:var." = v".a:var
	let getter1="function ".a:class.":get".a:var."()"
	let getter2="\treturn self.m".a:var
	let endStr="end"
	if a:sg=="set"
		return [setter1, setter2, endStr, ""]
	elseif a:sg=="get"
		return [getter1, getter2, endStr, ""]
	else
		return []
	endif
endfunction

"
function! s:GetMRUFile()
    " If the MRU file is present, then load the list of filenames. Otherwise
    " start with an empty list.
    if filereadable(g:MRU_File)
        let MRU_files = readfile(g:MRU_File)
        if l:MRU_files[0] =~# '^\s*" Most recently edited files in Vim'
            " Generated by the previous version of the MRU plugin.
            " Discard the list.
            let MRU_files = []
        elseif l:MRU_files[0] =~# '^#'
            " Remove the comment line
            call remove(l:MRU_files, 0)
        else
            " Unsupported format
            let MRU_files = []
        endif
    else
        let MRU_files = []
    endif
	let existFiles = []
	for mruName in l:MRU_files
		if filereadable(mruName)
			call add(existFiles, mruName)
		endif
	endfor
	return l:existFiles
endfunction

"
function! OpenFileByLine()
	let line=getline('.')
	if filereadable(l:line)
		exec "tabe ".l:line
	else
		echo "file not found"
	end
endfunction

" find file and open list below
function! s:searchFile(fileName, directory)
	if a:directory==""
		call system("find . |grep ".a:fileName." > ~/.vimtmp/search_list")
	else
		call system("find ".a:directory." |grep ".a:fileName." > ~/.vimtmp/search_list")
	endif
	botright 10 split ~/.vimtmp/search_list
	nnoremap <buffer><silent>t :call OpenFileByLine()<CR>
	setlocal nomodifiable
endfunction
function! s:searchFileInGit(fileName)
	let beforePath = getcwd()
	while 1
		let curPath = getcwd()
		if isdirectory(l:curPath."/.git")
			s:searchFile(fileName, curPath)
			break
		endif
	endwhile
	exec "cd ".beforePath
endfunction
command! -nargs=1 -bar SearchInGit call s:searchFileInGit(<q-args>)

" -----------------------------------------------------------------{{{ [[[
" open lastest openfile
function! OpenLastClose()
	let openFiles=s:GetAllBufferName()
	let closeFiles=s:GetMRUFile()
	for closeName in l:closeFiles
		let isClose = 1
		for openName in l:openFiles
			if l:openName == l:closeName
				let isClose = 0
				break
			endif
		endfor
		if l:isClose == 1
			exec "tabe ".closeName
			break
		endif
	endfor
endfunction

" search filename and open in mru list
function! OpenWithSingleFileName(fileName)
	let mruFiles=s:GetMRUFile()
	if a:fileName == ''
		call OpenLastClose()
		return
	endif
	for mruName in l:mruFiles
		let singleFileName = split(mruName, "/")[-1]
		if singleFileName == a:fileName
			exec "tabe ".mruName
			return
		endif
	endfor
	echo a:fileName." File not found.."
endfunction

" @cz MRU_SingleComplete
function! s:MRU_SingleComplete(ArgLead, CmdLine, CursorPos)
	let singleList = []
	let mruFiles = s:GetMRUFile()
	for pathFileName in l:mruFiles
		let singleFileName = split(pathFileName,"/")[-1]
		call add(singleList, singleFileName)
	endfor
    if a:ArgLead == ''
        " Return the complete list of MRU files
        return l:singleList
    else
        " Return only the files matching the specified pattern
        return filter(copy(l:singleList), 'v:val =~? a:ArgLead')
    endif
endfunction


nmap t :Tabe<space>
nmap <s-t> :Tabe<CR>
nmap s :SearchInGit<space>

command! -nargs=? -complete=customlist,s:MRU_SingleComplete Tabe
            \ call OpenWithSingleFileName(<q-args>)
"]]] }}}
"
"
"

